/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 assets/normal-microphone.glb -t 
*/

import * as THREE from "three"
import { useGLTF, useTexture } from "@react-three/drei"
import { GLTF } from "three-stdlib"
import { useCustomizeContext } from "../provider"
import { useEffect, useRef } from "react"
import { GroupProps, ThreeEvent, useFrame } from "@react-three/fiber"
import { usePathname } from "next/navigation"
import ImageDecal from "./decal"

type GLTFResult = GLTF & {
    nodes: {
        Shureobj001: THREE.Mesh
        Shureobj001_1: THREE.Mesh
        Shureobj001_2: THREE.Mesh
        Shureobj001_3: THREE.Mesh
        Plane: THREE.Mesh
    }
    materials: {
        ["Bottom handle"]: THREE.MeshStandardMaterial
        ["Capsule"]: THREE.MeshStandardMaterial
        ["Top handle"]: THREE.MeshStandardMaterial
        Material: THREE.MeshStandardMaterial
    }
}

interface MicrophoneProps extends GroupProps {
    draggingId: string | null
    setDraggingId: React.Dispatch<React.SetStateAction<string | null>>
}

export function Microphone({
    draggingId,
    setDraggingId,
    ...props
}: MicrophoneProps) {
    const { nodes, materials } = useGLTF(
        "/assets/normal-microphone.glb"
    ) as GLTFResult

    const {
        capsule,
        topHandle,
        bottomHandle,
        isRotating,
        setIsRotating,
        logos,
        setPart,
        focusedPart,
        setFocusedPart,
        focusStartTime,
        setFocusStartTime,
        updateLogo,
    } = useCustomizeContext()

    // Handle the material changing for each style
    useEffect(() => {
        if (capsule) {
            materials["Capsule"].color = new THREE.Color(capsule.color)
            materials["Capsule"].roughness = capsule.roughness
            materials["Capsule"].metalness = capsule.metalness
        }
        if (topHandle) {
            materials["Top handle"].color = new THREE.Color(topHandle.color)
            materials["Top handle"].roughness = topHandle.roughness
            materials["Top handle"].metalness = topHandle.metalness
        }
        if (bottomHandle) {
            materials["Bottom handle"].color = new THREE.Color(
                bottomHandle.color
            )
            materials["Bottom handle"].roughness = bottomHandle.roughness
            materials["Bottom handle"].metalness = bottomHandle.metalness
        }
    }, [capsule, topHandle, bottomHandle, materials])

    // Rotate the model on the y-axis while `isRotating` is true
    const modelRef = useRef<THREE.Group>(null)
    const pathname = usePathname()

    // Handle focused part when click the mesh
    const handleClick = (e: ThreeEvent<MouseEvent>, part: string) => {
        e.stopPropagation()
        if (isOrbiting.current) return // Prevent click if dragging

        setPart(part)
        setFocusedPart(part)
        setFocusStartTime(performance.now())
    }
    const duration = 1000
    useFrame(() => {
        if (modelRef.current && isRotating && pathname === "/customize") {
            modelRef.current.rotation.y += 0.003
        }

        if (focusedPart && focusStartTime !== null) {
            const elapsed = performance.now() - focusStartTime
            const loopDuration = 1000 // 1s loop

            const glowStrength = Math.abs(
                Math.sin((elapsed / loopDuration) * Math.PI)
            )

            const partMat =
                focusedPart === "Capsule"
                    ? materials["Capsule"]
                    : focusedPart === "Top Handle"
                    ? materials["Top handle"]
                    : focusedPart === "Bottom Handle"
                    ? materials["Bottom handle"]
                    : null

            if (partMat) {
                partMat.emissive = new THREE.Color(0xffffff)
                partMat.emissiveIntensity = glowStrength
            }

            if (elapsed > duration) {
                if (partMat) {
                    partMat.emissiveIntensity = 0
                }
                setFocusedPart(null)
                setFocusStartTime(null)
            }
        }
    })

    // Handlers to toggle rotation on mouse events and detect is orbiting
    const pointerDownPos = useRef<{ x: number; y: number } | null>(null)
    const isOrbiting = useRef(false)
    const handlePointerDown = (e: ThreeEvent<PointerEvent>) => {
        setIsRotating(false)
        pointerDownPos.current = { x: e.clientX, y: e.clientY }
        isOrbiting.current = false
    }
    const handlePointerMove = (e: ThreeEvent<PointerEvent>) => {
        if (!pointerDownPos.current) return
        const dx = e.clientX - pointerDownPos.current.x
        const dy = e.clientY - pointerDownPos.current.y
        if (Math.sqrt(dx * dx + dy * dy) > 5) {
            isOrbiting.current = true
        }
    }

    // Transform user uploaded images to textures for multiple decals
    // Use cloneImage for rendering, fallback to original image if cloneImage not available
    const logoImages =
        logos.length > 0
            ? logos.map((logo) => logo.cloneImage || logo.image)
            : ["/assets/transparent.png"]
    const logoTextures = useTexture(logoImages)
    const texturesArray = Array.isArray(logoTextures)
        ? logoTextures
        : [logoTextures]

    // Fix texture wrapping to prevent looping for all textures
    texturesArray.forEach((texture, index) => {
        if (texture && logos[index]) {
            texture.wrapS = THREE.ClampToEdgeWrapping
            texture.wrapT = THREE.ClampToEdgeWrapping
            texture.repeat.set(1, 1)
            texture.offset.set(0, 0)
        }
    })

    // chat's suggestion

    const meshRef = useRef<THREE.Mesh>(null!)
    const onPointerMove = (e: ThreeEvent<PointerEvent>) => {
        if (!draggingId) return
        e.stopPropagation()

        // world-space intersection point
        const worldPoint = e.point.clone()

        // convert to mesh-local coordinates
        const localPoint = meshRef.current.worldToLocal(worldPoint)

        // compute your decal’s polar coords:
        const radiusOffset = 0.05 // same offset you used
        const angle = Math.atan2(localPoint.x, localPoint.z - radiusOffset)
        const y = localPoint.y
        // update only that logo’s position
        updateLogo(draggingId, {
            position: [angle, y, /* keep your existing Z */ 0],
        })
    }
    return (
        <group
            dispose={null}
            onPointerDown={handlePointerDown}
            onPointerMove={handlePointerMove}
        >
            <group ref={modelRef} {...props}>
                <mesh
                    geometry={nodes.Shureobj001_2.geometry}
                    material={materials["Capsule"]}
                    onClick={(e) => handleClick(e, "Capsule")}
                    castShadow
                />
                <mesh
                    geometry={nodes.Shureobj001_3.geometry}
                    material={materials["Top handle"]}
                    onClick={(e) => handleClick(e, "Top Handle")}
                    castShadow
                >
                    {logos.map((logo, index) => (
                        <ImageDecal
                            setDraggingId={setDraggingId}
                            key={logo.id}
                            logo={logo}
                            texture={texturesArray[index]}
                        />
                    ))}
                </mesh>
                <mesh
                    ref={meshRef}
                    geometry={nodes.Shureobj001_1.geometry}
                    material={materials["Bottom handle"]}
                    onClick={(e) => handleClick(e, "Bottom Handle")}
                    castShadow
                    onPointerMove={onPointerMove}
                    onPointerMissed={() => setDraggingId(null)}
                >
                    {logos.map((logo, index) => (
                        <ImageDecal
                            setDraggingId={setDraggingId}
                            key={logo.id}
                            logo={logo}
                            texture={texturesArray[index]}
                        />
                    ))}
                </mesh>

                {/* Microphone Base */}
                <mesh
                    geometry={nodes.Shureobj001.geometry}
                    material={materials["Bottom handle"]}
                />
            </group>
        </group>
    )
}

useGLTF.preload("assets/normal-microphone.glb")
